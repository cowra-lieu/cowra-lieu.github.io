
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../SQL%E5%8A%A8%E6%80%81%E9%87%87%E6%A0%B7/">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.34">
    
    
      
        <title>基础知识 - 我的个人笔记库</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35f28582.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="我的个人笔记库" class="md-header__button md-logo" aria-label="我的个人笔记库" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            我的个人笔记库
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              基础知识
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="切换至深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换至深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="切换至浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换至浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../SQL%E5%8A%A8%E6%80%81%E9%87%87%E6%A0%B7/" class="md-tabs__link">
          
  
  PostgreSQL

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="我的个人笔记库" class="md-nav__button md-logo" aria-label="我的个人笔记库" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    我的个人笔记库
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    PostgreSQL
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            PostgreSQL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../SQL%E5%8A%A8%E6%80%81%E9%87%87%E6%A0%B7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SQL 动态采样
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    基础知识
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    基础知识
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#not-in-not-exists-left-join-b-where-bfield-is-none" class="md-nav__link">
    <span class="md-ellipsis">
      NOT IN 不走索引，改成 not exists 或者 left join b where b.field is none 性能更好？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="NOT IN 不走索引，改成 not exists 或者 left join b where b.field is none 性能更好？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#not-in" class="md-nav__link">
    <span class="md-ellipsis">
      为什么 NOT IN 经常不走索引？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      三种方案的对比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      优化建议
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#left-join" class="md-nav__link">
    <span class="md-ellipsis">
      left join 怎样保证查询结果中左边仅出现一次
    </span>
  </a>
  
    <nav class="md-nav" aria-label="left join 怎样保证查询结果中左边仅出现一次">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#distinct" class="md-nav__link">
    <span class="md-ellipsis">
      使用 DISTINCT (最直观但性能一般)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by" class="md-nav__link">
    <span class="md-ellipsis">
      使用 GROUP BY (适合聚合统计)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      使用子查询提前去重 (推荐)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#not-exists-in" class="md-nav__link">
    <span class="md-ellipsis">
      使用 NOT EXISTS 或 IN (性能最优，如果不需右表字段)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_number" class="md-nav__link">
    <span class="md-ellipsis">
      使用窗口函数 ROW_NUMBER() (最灵活)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      总结建议
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#distinct-on-id-distinct" class="md-nav__link">
    <span class="md-ellipsis">
      上面的 distinct on (id) 到底在干什么？和 distinct 的区别是？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="上面的 distinct on (id) 到底在干什么？和 distinct 的区别是？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#distinct_1" class="md-nav__link">
    <span class="md-ellipsis">
      DISTINCT (标准去重)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distinct-on-id" class="md-nav__link">
    <span class="md-ellipsis">
      DISTINCT ON (id) (按列去重)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      核心区别对比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      举个例子
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rank-dense_rank" class="md-nav__link">
    <span class="md-ellipsis">
      rank() 和 dense_rank() 是什么？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="rank() 和 dense_rank() 是什么？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rank" class="md-nav__link">
    <span class="md-ellipsis">
      RANK()：跳跃排名
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dense_rank" class="md-nav__link">
    <span class="md-ellipsis">
      DENSE_RANK()：连续排名
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      直观对比图
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      基本语法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      什么时候用哪个？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over" class="md-nav__link">
    <span class="md-ellipsis">
      为什么 OVER() 里的内容是一样的？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      进阶：分组排名（每个部门的前三名）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      总结三者关系
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lagled" class="md-nav__link">
    <span class="md-ellipsis">
      lag,led是什么？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="lag,led是什么？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      语法结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      实战案例：计算环比增长率
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      进阶参数：处理空值和偏移量
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      常见应用场景
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      连续 3 天登录的用户
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#group-by-having-having-where" class="md-nav__link">
    <span class="md-ellipsis">
      group by 后面的 having 是干什么的？为什么要 having, where 不行嘛？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="group by 后面的 having 是干什么的？为什么要 having, where 不行嘛？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      执行顺序的本质区别
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#where" class="md-nav__link">
    <span class="md-ellipsis">
      为什么 WHERE 不行？
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opengauss-sql" class="md-nav__link">
    <span class="md-ellipsis">
      openGauss 慢 SQL 监控
    </span>
  </a>
  
    <nav class="md-nav" aria-label="openGauss 慢 SQL 监控">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sql" class="md-nav__link">
    <span class="md-ellipsis">
      查看当前正在运行的慢 SQL
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-wdr" class="md-nav__link">
    <span class="md-ellipsis">
      查看历史累计最耗时的 SQL (WDR 报告基础)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      如何选择过滤工具？
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#not-in-not-exists-left-join-b-where-bfield-is-none" class="md-nav__link">
    <span class="md-ellipsis">
      NOT IN 不走索引，改成 not exists 或者 left join b where b.field is none 性能更好？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="NOT IN 不走索引，改成 not exists 或者 left join b where b.field is none 性能更好？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#not-in" class="md-nav__link">
    <span class="md-ellipsis">
      为什么 NOT IN 经常不走索引？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      三种方案的对比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      优化建议
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#left-join" class="md-nav__link">
    <span class="md-ellipsis">
      left join 怎样保证查询结果中左边仅出现一次
    </span>
  </a>
  
    <nav class="md-nav" aria-label="left join 怎样保证查询结果中左边仅出现一次">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#distinct" class="md-nav__link">
    <span class="md-ellipsis">
      使用 DISTINCT (最直观但性能一般)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by" class="md-nav__link">
    <span class="md-ellipsis">
      使用 GROUP BY (适合聚合统计)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      使用子查询提前去重 (推荐)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#not-exists-in" class="md-nav__link">
    <span class="md-ellipsis">
      使用 NOT EXISTS 或 IN (性能最优，如果不需右表字段)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_number" class="md-nav__link">
    <span class="md-ellipsis">
      使用窗口函数 ROW_NUMBER() (最灵活)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      总结建议
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#distinct-on-id-distinct" class="md-nav__link">
    <span class="md-ellipsis">
      上面的 distinct on (id) 到底在干什么？和 distinct 的区别是？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="上面的 distinct on (id) 到底在干什么？和 distinct 的区别是？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#distinct_1" class="md-nav__link">
    <span class="md-ellipsis">
      DISTINCT (标准去重)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distinct-on-id" class="md-nav__link">
    <span class="md-ellipsis">
      DISTINCT ON (id) (按列去重)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      核心区别对比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      举个例子
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rank-dense_rank" class="md-nav__link">
    <span class="md-ellipsis">
      rank() 和 dense_rank() 是什么？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="rank() 和 dense_rank() 是什么？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rank" class="md-nav__link">
    <span class="md-ellipsis">
      RANK()：跳跃排名
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dense_rank" class="md-nav__link">
    <span class="md-ellipsis">
      DENSE_RANK()：连续排名
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      直观对比图
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      基本语法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      什么时候用哪个？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over" class="md-nav__link">
    <span class="md-ellipsis">
      为什么 OVER() 里的内容是一样的？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      进阶：分组排名（每个部门的前三名）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      总结三者关系
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lagled" class="md-nav__link">
    <span class="md-ellipsis">
      lag,led是什么？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="lag,led是什么？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      语法结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      实战案例：计算环比增长率
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      进阶参数：处理空值和偏移量
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      常见应用场景
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      连续 3 天登录的用户
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#group-by-having-having-where" class="md-nav__link">
    <span class="md-ellipsis">
      group by 后面的 having 是干什么的？为什么要 having, where 不行嘛？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="group by 后面的 having 是干什么的？为什么要 having, where 不行嘛？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      执行顺序的本质区别
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#where" class="md-nav__link">
    <span class="md-ellipsis">
      为什么 WHERE 不行？
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opengauss-sql" class="md-nav__link">
    <span class="md-ellipsis">
      openGauss 慢 SQL 监控
    </span>
  </a>
  
    <nav class="md-nav" aria-label="openGauss 慢 SQL 监控">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sql" class="md-nav__link">
    <span class="md-ellipsis">
      查看当前正在运行的慢 SQL
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-wdr" class="md-nav__link">
    <span class="md-ellipsis">
      查看历史累计最耗时的 SQL (WDR 报告基础)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      如何选择过滤工具？
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">基础知识</h1>
<h2 id="not-in-not-exists-left-join-b-where-bfield-is-none">NOT IN 不走索引，改成 not exists 或者 left join b where b.field is none 性能更好？</h2>
<p>这是一个非常经典的 SQL 优化问题。直接回答你：在 openGauss 或 PostgreSQL 环境下，通常 NOT EXISTS 或 LEFT JOIN ... IS NULL 的性能确实会更好，且更安全。</p>
<p>不过，之所以“索引失效”或“性能差”，背后有几个关键的技术细节需要你注意。</p>
<h3 id="not-in">为什么 NOT IN 经常不走索引？</h3>
<p>最重要的原因是 NULL 值的逻辑处理。</p>
<ol>
<li>三值逻辑陷阱：根据 SQL 标准，如果 NOT IN 后面的子查询结果集中包含一个 NULL 值，那么整个 NOT IN 表达式的结果都会变成 UNKNOWN。这意味着结果集会直接返回空，数据库为了保证这个逻辑的正确性，往往无法直接利用简单的索引扫描。</li>
<li>全表扫描风险：即使字段定义了 NOT NULL，在复杂的执行计划中，优化器有时也会保守地选择全表扫描（Seq Scan）来处理 NOT IN 的过滤逻辑。</li>
</ol>
<h3 id="_2">三种方案的对比</h3>
<p>假设你有两张表：A (大表) 和 B (关联表)。</p>
<p>方案 A：NOT IN (最不推荐)</p>
<pre><code class="language-sql">SELECT * FROM A WHERE id NOT IN (SELECT id FROM B);
</code></pre>
<p>风险：如果 B.id 有一个为 NULL，整条查询直接哑火（返回空）。
性能：容易触发笛卡尔积式的逻辑，在大数据量下表现极差。</p>
<p>方案 B：NOT EXISTS (推荐：语义最清晰)</p>
<pre><code class="language-sql">SELECT * FROM A WHERE NOT EXISTS (
    SELECT 1 FROM B WHERE B.id = A.id
);
</code></pre>
<p>原理：只要在 B 表中找到第一条匹配的记录，就会立即停止扫描。
索引：它能完美触发 B.id 上的索引。
优势： openGauss 优化器通常会将其优化为 Anti-Join (反连接)，效率极高。</p>
<p>方案 C：LEFT JOIN ... IS NULL (推荐：适合复杂统计)</p>
<pre><code class="language-sql">SELECT A.* FROM A 
LEFT JOIN B ON A.id = B.id 
WHERE B.id IS NULL;
</code></pre>
<p>原理：先做左外连接，然后滤掉关联成功的行。</p>
<p>性能：在现代优化器中，它和 NOT EXISTS 的执行计划几乎是一样的（都会走 Hash Anti Join 或 Merge Anti Join）。
特性,NOT IN,NOT EXISTS,LEFT JOIN ... IS NULL
空值敏感度,极其敏感（易出错）,屏蔽空值（更安全）,屏蔽空值（更安全）
执行计划,经常走 Seq Scan,常用 Hash Anti Join,常用 Hash Anti Join
索引利用率,低,高,高
首选场景,仅限小集合常量,绝大多数关联场景,需要返回 B 表数据时</p>
<h3 id="_3">优化建议</h3>
<p>首选 NOT EXISTS：它的代码意图最直观，且在 openGauss 中会被高效处理。</p>
<p>确保索引：无论改用哪种，B.id（被参照的列）必须建立索引。</p>
<p>强制非空：如果你一定要用 NOT IN，请务必在子查询中加上 WHERE id IS NOT NULL，这有时能引导优化器重新选择索引扫描。</p>
<h2 id="left-join">left join 怎样保证查询结果中左边仅出现一次</h2>
<p>要保证左表结果仅出现一次，通常有以下四种优化方案，你可以根据业务需求选择最合适的一种：</p>
<h3 id="distinct">使用 DISTINCT (最直观但性能一般)</h3>
<p>如果你只需要左表的字段，且不关心右表的具体内容，可以直接去重。</p>
<pre><code class="language-sql">SELECT DISTINCT A.* FROM A 
LEFT JOIN B ON A.id = B.id;
</code></pre>
<p>适用场景：结果集较小，且只需要 A 表的列。</p>
<p>缺点：数据库需要先做 Join 生成大表，再进行全量排序去重，数据量大时非常慢。</p>
<h3 id="group-by">使用 GROUP BY (适合聚合统计)</h3>
<p>如果你需要引用右表的一些统计信息（比如关联了多少条、最大日期等）。</p>
<pre><code class="language-sql">SELECT A.id, A.name, MAX(B.created_at) as latest_b
FROM A 
LEFT JOIN B ON A.id = B.id
GROUP BY A.id, A.name;
</code></pre>
<p>适用场景：需要显示左表信息的同时，带上右表的汇总数据。</p>
<h3 id="_4">使用子查询提前去重 (推荐)</h3>
<p>在 Join 之前，先让右表变得“唯一”。</p>
<pre><code class="language-sql">SELECT A.*, B_temp.some_col
FROM A
LEFT JOIN (
    SELECT DISTINCT ON (id) id, some_col 
    FROM B 
    ORDER BY id, created_at DESC
) B_temp ON A.id = B_temp.id;
</code></pre>
<p>注意：openGauss/PostgreSQL 支持 DISTINCT ON，这能让你在去重时精准控制保留哪一行（比如保留最新的记录）。</p>
<h3 id="not-exists-in">使用 NOT EXISTS 或 IN (性能最优，如果不需右表字段)</h3>
<p>如果你做 LEFT JOIN 只是为了过滤（即：只看那些在 B 表中有/没有记录的 A），那么根本不该用 Join。</p>
<pre><code class="language-sql">-- 只要在 B 中存在，A 就只显示一次
SELECT * FROM A 
WHERE EXISTS (SELECT 1 FROM B WHERE B.id = A.id);
</code></pre>
<p>优点：这是性能最好的方式。优化器在发现第一条匹配记录后就会停止扫描 B 表，不会产生重复行。</p>
<h3 id="row_number">使用窗口函数 ROW_NUMBER() (最灵活)</h3>
<p>如果你需要从右表中取出某一行特定的数据（例如：每个用户最近的一次订单信息）。</p>
<pre><code class="language-sql">SELECT * FROM (
    SELECT A.*, B.order_no,
           ROW_NUMBER() OVER(PARTITION BY A.id ORDER BY B.order_date DESC) as rn
    FROM A
    LEFT JOIN B ON A.id = B.id
) t
WHERE rn = 1;
</code></pre>
<h3 id="_5">总结建议</h3>
<p>需求场景,推荐方案
纯粹为了过滤是否存在,使用 EXISTS
需要右表的汇总数据,使用 GROUP BY
需要右表中“最新的”那一行,使用 ROW_NUMBER() 或 DISTINCT ON
数据量极小，图省事,使用 DISTINCT</p>
<h2 id="distinct-on-id-distinct">上面的 distinct on (id) 到底在干什么？和 distinct 的区别是？</h2>
<p>在 openGauss 和 PostgreSQL 的方言中，DISTINCT ON 是一个极具威力的特性，它比标准的 DISTINCT 要灵活得多。</p>
<p>简单来说：DISTINCT 是对“整行”去重，而 DISTINCT ON 是按“指定的列”去重。</p>
<h3 id="distinct_1">DISTINCT (标准去重)</h3>
<p>当你写 SELECT DISTINCT id, some_col FROM B 时：
数据库会检查 id 和 some_col 的组合。
只有当两行数据的这两个字段完全一样时，才会合并。</p>
<p>局限性：你无法控制如果 id 相同但 some_col 不同时，到底保留哪一行。</p>
<h3 id="distinct-on-id">DISTINCT ON (id) (按列去重)</h3>
<p>当你写 SELECT DISTINCT ON (id) id, some_col FROM B ORDER BY id, created_at DESC 时：</p>
<p>分组：数据库将所有数据按 id 进行逻辑分组。
排序：在每个 id 组内，按照 ORDER BY 后的 created_at DESC 进行排序。
提取：只取每组的第一行，丢弃其余行。</p>
<p>为什么它在你的 LEFT JOIN 中很有用？
在你的例子中，由于加了 ORDER BY id, created_at DESC，DISTINCT ON (id) 保证了对于每一个 id，只返回最近创建的那一条记录的 some_col。这样在与 A 表连接时，就不会因为 B 表中有重复的 id 而导致 A 表的数据翻倍。</p>
<h3 id="_6">核心区别对比</h3>
<p>特性,DISTINCT,DISTINCT ON (col)
去重范围,作用于 SELECT 列表中的所有列。,作用于括号内指定的列。
数据保留,只要有一列不同，就会保留。,只要括号内的列相同，就只留一行。
控制力,无法控制保留哪一行（随机性）。,配合 ORDER BY 可以精准控制保留哪一行（如最新、最贵）。
语法强制,无需配合 ORDER BY。,强制要求 ORDER BY 的最左侧列必须包含在 DISTINCT ON 中。</p>
<h3 id="_7">举个例子</h3>
<p>假设表 B 数据如下：
id,some_col,created_at
1,"""苹果""",2023-01-01
1,"""香蕉""",2023-05-01</p>
<p>执行 DISTINCT：你会得到 2 行，因为“苹果”和“香蕉”不同。</p>
<p>执行 DISTINCT ON (id) ... ORDER BY id, created_at DESC：你只会得到 1 行：1, "香蕉"。</p>
<p>注意事项 (openGauss 避坑)
排序要求：使用 DISTINCT ON 时，ORDER BY 的第一个表达式必须与 DISTINCT ON 括号里的表达式匹配。例如 DISTINCT ON (id) 必须对应 ORDER BY id, ...。</p>
<p>性能：在数据量巨大且没有合适索引时，DISTINCT ON 会触发物理排序，比较耗时。如果 B.id 和 B.created_at 有联合索引，性能会非常快。</p>
<h2 id="rank-dense_rank">rank() 和 dense_rank() 是什么？</h2>
<p>在 openGauss、PostgreSQL 以及几乎所有的主流关系型数据库中，RANK() 和 DENSE_RANK() 都是窗口函数，专门用于对数据进行排名。</p>
<p>它们最大的区别在于：当出现“并列第一（平分）”的情况时，如何处理后续的排名序号。</p>
<h3 id="rank">RANK()：跳跃排名</h3>
<p>如果两个人并列第一，那么下一个人的排名会跳过第二名，直接变成第三名。</p>
<p>特点：总排名会反映出总人数。如果有两个第 1 名，接下来的就是第 3 名。</p>
<h3 id="dense_rank">DENSE_RANK()：连续排名</h3>
<p>即使有并列第一，排名也是连续的，不会跳号。</p>
<p>特点：排名是“紧凑（Dense）”的。如果有两个第 1 名，接下来的依然是第 2 名。</p>
<h3 id="_8">直观对比图</h3>
<p>假设有一组考试成绩：
姓名,成绩,RANK(),DENSE_RANK(),ROW_NUMBER() (对比用)
张三,100,1,1,1
李四,100,1,1,2
王五,95,3 (跳过了2),2 (连续),3
赵六,90,4,3,4</p>
<h3 id="_9">基本语法</h3>
<p>它们的语法结构完全一致：</p>
<pre><code class="language-sql">SELECT 
    name, 
    score,
    RANK() OVER (ORDER BY score DESC) as rank_val,
    DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank_val
FROM students;
</code></pre>
<p>OVER: 开启窗口函数。</p>
<p>ORDER BY: 决定按什么标准排名（通常降序 DESC 代表从高分到低分）。</p>
<p>PARTITION BY (可选): 如果你想按班级排名（每个班级内部重新从 1 开始排），可以在 ORDER BY 前加上 PARTITION BY class_id。</p>
<h3 id="_10">什么时候用哪个？</h3>
<ul>
<li>用 RANK() 的场景： 通常用于竞赛或正式排名。比如奥林匹克比赛，如果有两个并列金牌，接下来的那个人领的就是铜牌（第三名），而不是银牌。</li>
<li>用 DENSE_RANK() 的场景： 通常用于等级划分。比如你想知道成绩最好的前三个分数段，而不关心有多少人拿了最高分。</li>
<li>用 ROW_NUMBER() 的场景（顺便提一下）： 如果你不需要考虑并列，只是单纯想给每一行打个唯一的序号（比如分页查询），那就用 ROW_NUMBER()。</li>
</ul>
<p>总结口诀
RANK 是“占位”的：有人并列，位子也占着，后面的人往后挪。</p>
<p>DENSE_RANK 是“排队”的：有人并列，名次照样数，后面的人不吃亏。</p>
<p>你想针对你的 openGauss 数据库写一个具体的“分组排名”查询（比如查询每个部门薪水最高的前三名）吗？我可以帮你写出完整的 SQL。</p>
<p>在 SQL 中，ROW_NUMBER() 的用法与 RANK()、DENSE_RANK() 完全一致。</p>
<p>即使你不需要考虑并列情况，OVER() 子句中的内容通常也是相同的，因为它们都需要基于同样的排序逻辑来计算序号。</p>
<ol>
<li>完整 SQL 示例
你可以直接运行这段代码，它会将三种排名方式并列显示：</li>
</ol>
<pre><code class="language-sql">SELECT 
    name, 
    score,
    -- 无论分数是否相同，序号永远唯一且连续 (1, 2, 3, 4...)
    ROW_NUMBER() OVER (ORDER BY score DESC) as row_num,

    -- 分数相同时序号相同，但会跳过后续序号 (1, 1, 3...)
    RANK() OVER (ORDER BY score DESC) as rank_val,

    -- 分数相同时序号相同，且序号连续 (1, 1, 2...)
    DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank_val
FROM students;
</code></pre>
<h3 id="over">为什么 OVER() 里的内容是一样的？</h3>
<p>OVER() 子句的作用是定义<strong>“窗口”</strong>，也就是告诉数据库：</p>
<p>怎么切分数据？ (PARTITION BY) —— 比如按班级切分。</p>
<p>按什么顺序排？ (ORDER BY) —— 比如按成绩从高到低。</p>
<p>在这个查询中，三者共用 ORDER BY score DESC，是因为你想在同一个“成绩单”视角下观察它们处理并列分数的不同逻辑。</p>
<h3 id="_11">进阶：分组排名（每个部门的前三名）</h3>
<p>如果你想查询每个部门（department）中，成绩最高的前 3 名，代码应该这样写：</p>
<pre><code class="language-sql">SELECT * FROM (
    SELECT 
        name, 
        department,
        score,
        -- 在每个部门内部独立排名
        DENSE_RANK() OVER (PARTITION BY department ORDER BY score DESC) as dr
    FROM students
) t
WHERE t.dr &lt;= 3;
</code></pre>
<p>PARTITION BY department: 就像是把学生按部门分到了不同的房间里，每个房间的人都从 1 开始重新排名。</p>
<p>外层嵌套: 必须先在子查询里算出排名，外层才能用 WHERE 过滤（因为窗口函数在 SQL 执行顺序中非常靠后）。</p>
<h3 id="_12">总结三者关系</h3>
<p>函数,结果序列（遇并列）,特点,常用场景
ROW_NUMBER(),"1, 2, 3, 4",绝对唯一,分页、去重、取第一条
RANK(),"1, 1, 3, 4",总数不变,体育比赛、正式名次
DENSE_RANK(),"1, 1, 2, 3",等级连续,绩效评级、分数段统计</p>
<h2 id="lagled">lag,led是什么？</h2>
<p>在 openGauss 和 PostgreSQL 的窗口函数世界里，LAG() 和 LEAD() 被称为“偏移函数”。它们的作用非常强大：让你在当前行就能直接读到“上一行”或“下一行”的数据。 这在处理时间序列、计算环比增长或查找状态变更时简直是神器。1. 基本定义LAG(column, n): 获取当前行之前的第 $n$ 行数据（向上看）。LEAD(column, n): 获取当前行之后的第 $n$ 行数据（向下看）。$n$ 默认为 1（即相邻行）。如果找不到对应行（比如第一行的上一行），默认返回 NULL。</p>
<h3 id="_13">语法结构</h3>
<pre><code class="language-sql">SELECT 
    dt, 
    sales,
    -- 获取昨天的销售额
    LAG(sales, 1) OVER (ORDER BY dt) as yesterday_sales,
    -- 获取明天的销售额
    LEAD(sales, 1) OVER (ORDER BY dt) as tomorrow_sales
FROM daily_sales;
</code></pre>
<h3 id="_14">实战案例：计算环比增长率</h3>
<p>假设你有一张月度营收表，想计算每个月比上个月增长了多少：</p>
<pre><code class="language-sql">SELECT 
    month,
    revenue,
    LAG(revenue) OVER (ORDER BY month) as last_month_revenue,
    -- 计算增长率：(本月 - 上月) / 上月
    (revenue - LAG(revenue) OVER (ORDER BY month)) / LAG(revenue) OVER (ORDER BY month) * 100 || '%' as growth_rate
FROM monthly_report;
</code></pre>
<h3 id="_15">进阶参数：处理空值和偏移量</h3>
<p>LAG 和 LEAD 其实支持三个参数： LAG(column, offset, default_value)</p>
<ol>
<li>column: 你要读取的列。</li>
<li>offset: 偏移量（比如填 7 就是看上周同一天）。</li>
<li>default_value: 当没有上一行时，用什么代替 NULL（比如填 0）。</li>
</ol>
<pre><code class="language-sql">-- 如果没有上一行数据，就显示 0
SELECT LAG(price, 1, 0) OVER (ORDER BY id) FROM products;
</code></pre>
<h3 id="_16">常见应用场景</h3>
<ul>
<li>计算差值：如今日股价与昨日股价的差。</li>
<li>判断状态变化：对比当前行状态和上一行状态，如果不一致，说明状态发生了切换。</li>
<li>计算时间间隔：计算用户本次点击与上次点击之间隔了多少秒。</li>
</ul>
<p>窗口函数全家桶总结
至此，你已经接触了窗口函数中最核心的三类：</p>
<ul>
<li>排名类：ROW_NUMBER, RANK, DENSE_RANK（解决“谁是第一”）。</li>
<li>偏移类：LAG, LEAD（解决“昨天和今天比”）。</li>
<li>聚合类：SUM(...) OVER, AVG(...) OVER（解决“个人与平均水平比”）。</li>
</ul>
<p>你想尝试写一个复杂的查询吗？比如：找出连续 3 天登录的用户。这类问题通常需要将 LAG 或 LEAD 组合使用。</p>
<h2 id="3">连续 3 天登录的用户</h2>
<p>这是一个非常经典的 SQL 面试题及实战场景。要找出<strong>“连续 3 天登录的用户”</strong>，我们可以利用 LAG（看前几天）或者 LEAD（看后几天）来跨行对比日期。</p>
<p>假设你的表名为 user_log，字段有 user_id 和 login_date。</p>
<p>方案一：使用 LAG 函数（向前看）
逻辑：如果一个用户“今天的日期”、“昨天的日期”、“前天的日期”是连续的，那么他就是连续 3 天登录。</p>
<pre><code class="language-sql">SELECT DISTINCT user_id
FROM (
    SELECT 
        user_id,
        login_date,
        -- 获取上一次登录日期
        LAG(login_date, 1) OVER (PARTITION BY user_id ORDER BY login_date) as last_1_day,
        -- 获取上上次登录日期
        LAG(login_date, 2) OVER (PARTITION BY user_id ORDER BY login_date) as last_2_day
    FROM (
        -- 先去重，防止同一天多次登录干扰计算
        SELECT DISTINCT user_id, login_date FROM user_log
    ) as sub_logs
) as t
WHERE login_date = last_1_day + 1  -- 今天 = 昨天 + 1天
  AND last_1_day = last_2_day + 1; -- 昨天 = 前天 + 1天
</code></pre>
<p>方案二：差值法（高级且通用）
如果要求的是“连续 7 天”甚至更长，写一堆 LAG 会非常痛苦。这时候可以用差值分组法。</p>
<p>核心思想： 如果日期是连续的（如 1号, 2号, 3号），而行号也是连续的（如 1, 2, 3），那么 日期 - 行号 得到的结果必然是同一个常量。</p>
<pre><code class="language-sql">SELECT user_id
FROM (
    SELECT 
        user_id,
        login_date,
        -- 日期减去行号，得到一个基准日期
        login_date - CAST(ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY login_date) AS INT) as grp
    FROM (SELECT DISTINCT user_id, login_date FROM user_log)
) t
GROUP BY user_id, grp
HAVING COUNT(*) &gt;= 3; -- 只要同一个基准日期的行数 &gt;= 3，就是连续 3 天
</code></pre>
<p>窗口函数学习小结
恭喜你！到这里你已经掌握了 openGauss/PostgreSQL 中最高级的查询技巧：</p>
<p>DISTINCT ON: 解决“每组只取一个”的去重问题。</p>
<p>RANK/DENSE_RANK/ROW_NUMBER: 解决“名次”和“唯一序号”问题。</p>
<p>LAG/LEAD: 解决“跨行对比”和“趋势分析”问题。</p>
<p>OVER(PARTITION BY ... ORDER BY ...): 窗口函数的核心语法骨架。</p>
<h2 id="group-by-having-having-where">group by 后面的 having 是干什么的？为什么要 having, where 不行嘛？</h2>
<p>简单来说：WHERE 作用于“行”（过滤原始数据），而 HAVING 作用于“组”（过滤聚合后的结果）。</p>
<h3 id="_17">执行顺序的本质区别</h3>
<p>SQL 的执行顺序（逻辑上）是这样的：</p>
<ol>
<li>FROM / JOIN：找到表。</li>
<li>WHERE：在分组前，把不符合条件的行扔掉。</li>
<li>GROUP BY：把剩下的行分成小组。</li>
<li>聚合函数 (SUM, COUNT, AVG)：计算每个小组的统计值。</li>
<li>HAVING：在分组计算完成后，把不符合条件的小组扔掉。</li>
</ol>
<h3 id="where">为什么 WHERE 不行？</h3>
<p>如果你想查“平均分大于 80 的班级”，你会发现：</p>
<pre><code class="language-sql">-- 报错！因为执行 WHERE 时，数据库还没算出平均分呢
SELECT class_id, AVG(score) 
FROM students 
WHERE AVG(score) &gt; 80 
GROUP BY class_id;
</code></pre>
<p>报错原因：WHERE 后面严禁使用聚合函数。它只能看单行数据的列。 正确写法：</p>
<pre><code class="language-sql">SELECT class_id, AVG(score) 
FROM students 
GROUP BY class_id 
HAVING AVG(score) &gt; 80;
</code></pre>
<h2 id="opengauss-sql">openGauss 慢 SQL 监控</h2>
<p>在 DataGrip 中，如果你有足够的权限，可以通过 openGauss 内置的性能视图直接定位那些“跑得慢”的语句。</p>
<h3 id="sql">查看当前正在运行的慢 SQL</h3>
<p>如果你发现数据库卡住了，执行这个：</p>
<pre><code class="language-sql">SELECT 
    query_id, 
    start_time, 
    now() - start_time AS duration, -- 已运行时间
    query 
FROM pg_stat_activity 
WHERE state != 'idle'               -- 排除空闲连接
ORDER BY duration DESC;
</code></pre>
<h3 id="sql-wdr">查看历史累计最耗时的 SQL (WDR 报告基础)</h3>
<p>openGauss 提供了一个非常强大的视图 dbe_perf.statement（或者在某些版本中是 pg_stat_statements），它记录了 SQL 的执行次数、总耗时等。</p>
<pre><code class="language-sql">SELECT 
    user_name,
    query,
    n_calls as 执行次数,
    total_elapse_time / n_calls as 平均耗时_ms,
    n_soft_parse as 软解析,
    n_hard_parse as 硬解析
FROM dbe_perf.statement
ORDER BY 平均耗时_ms DESC
LIMIT 10;
</code></pre>
<h2 id="_18">如何选择过滤工具？</h2>
<p>工具,过滤对象,允许聚合函数？,场景示例
WHERE,原始行数据,否,找出所有 2025 年的订单
HAVING,分组后的统计结果,是,找出订单总额超过 100 万的客户
QUALIFY,窗口函数的结果,是,(高级用法) 过滤 ROW_NUMBER() 结果</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.sections", "navigation.expand", "navigation.top", "content.code.copy", "content.code.annotate", "search.suggest"], "search": "../../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.56dfad97.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@10/dist/mermaid.min.js"></script>
      
    
  </body>
</html>