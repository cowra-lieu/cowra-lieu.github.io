# 基础知识

## NOT IN 不走索引，改成 not exists 或者 left join b where b.field is none 性能更好？

这是一个非常经典的 SQL 优化问题。直接回答你：在 openGauss 或 PostgreSQL 环境下，通常 NOT EXISTS 或 LEFT JOIN ... IS NULL 的性能确实会更好，且更安全。

不过，之所以“索引失效”或“性能差”，背后有几个关键的技术细节需要你注意。

### 为什么 NOT IN 经常不走索引？

最重要的原因是 NULL 值的逻辑处理。

1. 三值逻辑陷阱：根据 SQL 标准，如果 NOT IN 后面的子查询结果集中包含一个 NULL 值，那么整个 NOT IN 表达式的结果都会变成 UNKNOWN。这意味着结果集会直接返回空，数据库为了保证这个逻辑的正确性，往往无法直接利用简单的索引扫描。
2. 全表扫描风险：即使字段定义了 NOT NULL，在复杂的执行计划中，优化器有时也会保守地选择全表扫描（Seq Scan）来处理 NOT IN 的过滤逻辑。

### 三种方案的对比

假设你有两张表：A (大表) 和 B (关联表)。

方案 A：NOT IN (最不推荐)

```sql
SELECT * FROM A WHERE id NOT IN (SELECT id FROM B);
```

风险：如果 B.id 有一个为 NULL，整条查询直接哑火（返回空）。
性能：容易触发笛卡尔积式的逻辑，在大数据量下表现极差。

方案 B：NOT EXISTS (推荐：语义最清晰)

```sql
SELECT * FROM A WHERE NOT EXISTS (
    SELECT 1 FROM B WHERE B.id = A.id
);
```

原理：只要在 B 表中找到第一条匹配的记录，就会立即停止扫描。
索引：它能完美触发 B.id 上的索引。
优势： openGauss 优化器通常会将其优化为 Anti-Join (反连接)，效率极高。

方案 C：LEFT JOIN ... IS NULL (推荐：适合复杂统计)

```sql
SELECT A.* FROM A 
LEFT JOIN B ON A.id = B.id 
WHERE B.id IS NULL;
```

原理：先做左外连接，然后滤掉关联成功的行。

性能：在现代优化器中，它和 NOT EXISTS 的执行计划几乎是一样的（都会走 Hash Anti Join 或 Merge Anti Join）。
特性,NOT IN,NOT EXISTS,LEFT JOIN ... IS NULL
空值敏感度,极其敏感（易出错）,屏蔽空值（更安全）,屏蔽空值（更安全）
执行计划,经常走 Seq Scan,常用 Hash Anti Join,常用 Hash Anti Join
索引利用率,低,高,高
首选场景,仅限小集合常量,绝大多数关联场景,需要返回 B 表数据时

### 优化建议

首选 NOT EXISTS：它的代码意图最直观，且在 openGauss 中会被高效处理。

确保索引：无论改用哪种，B.id（被参照的列）必须建立索引。

强制非空：如果你一定要用 NOT IN，请务必在子查询中加上 WHERE id IS NOT NULL，这有时能引导优化器重新选择索引扫描。

## left join 怎样保证查询结果中左边仅出现一次

要保证左表结果仅出现一次，通常有以下四种优化方案，你可以根据业务需求选择最合适的一种：

### 使用 DISTINCT (最直观但性能一般)

如果你只需要左表的字段，且不关心右表的具体内容，可以直接去重。

```sql
SELECT DISTINCT A.* FROM A 
LEFT JOIN B ON A.id = B.id;
```

适用场景：结果集较小，且只需要 A 表的列。

缺点：数据库需要先做 Join 生成大表，再进行全量排序去重，数据量大时非常慢。

### 使用 GROUP BY (适合聚合统计)

如果你需要引用右表的一些统计信息（比如关联了多少条、最大日期等）。

```sql
SELECT A.id, A.name, MAX(B.created_at) as latest_b
FROM A 
LEFT JOIN B ON A.id = B.id
GROUP BY A.id, A.name;
```

适用场景：需要显示左表信息的同时，带上右表的汇总数据。

### 使用子查询提前去重 (推荐)

在 Join 之前，先让右表变得“唯一”。

```sql
SELECT A.*, B_temp.some_col
FROM A
LEFT JOIN (
    SELECT DISTINCT ON (id) id, some_col 
    FROM B 
    ORDER BY id, created_at DESC
) B_temp ON A.id = B_temp.id;
```

注意：openGauss/PostgreSQL 支持 DISTINCT ON，这能让你在去重时精准控制保留哪一行（比如保留最新的记录）。

### 使用 NOT EXISTS 或 IN (性能最优，如果不需右表字段)

如果你做 LEFT JOIN 只是为了过滤（即：只看那些在 B 表中有/没有记录的 A），那么根本不该用 Join。

```sql
-- 只要在 B 中存在，A 就只显示一次
SELECT * FROM A 
WHERE EXISTS (SELECT 1 FROM B WHERE B.id = A.id);
```

优点：这是性能最好的方式。优化器在发现第一条匹配记录后就会停止扫描 B 表，不会产生重复行。

### 使用窗口函数 ROW_NUMBER() (最灵活)

如果你需要从右表中取出某一行特定的数据（例如：每个用户最近的一次订单信息）。

```sql
SELECT * FROM (
    SELECT A.*, B.order_no,
           ROW_NUMBER() OVER(PARTITION BY A.id ORDER BY B.order_date DESC) as rn
    FROM A
    LEFT JOIN B ON A.id = B.id
) t
WHERE rn = 1;
```

### 总结建议

需求场景,推荐方案
纯粹为了过滤是否存在,使用 EXISTS
需要右表的汇总数据,使用 GROUP BY
需要右表中“最新的”那一行,使用 ROW_NUMBER() 或 DISTINCT ON
数据量极小，图省事,使用 DISTINCT

## 上面的 distinct on (id) 到底在干什么？和 distinct 的区别是？

在 openGauss 和 PostgreSQL 的方言中，DISTINCT ON 是一个极具威力的特性，它比标准的 DISTINCT 要灵活得多。

简单来说：DISTINCT 是对“整行”去重，而 DISTINCT ON 是按“指定的列”去重。

### DISTINCT (标准去重)

当你写 SELECT DISTINCT id, some_col FROM B 时：
数据库会检查 id 和 some_col 的组合。
只有当两行数据的这两个字段完全一样时，才会合并。

局限性：你无法控制如果 id 相同但 some_col 不同时，到底保留哪一行。

### DISTINCT ON (id) (按列去重)

当你写 SELECT DISTINCT ON (id) id, some_col FROM B ORDER BY id, created_at DESC 时：

分组：数据库将所有数据按 id 进行逻辑分组。
排序：在每个 id 组内，按照 ORDER BY 后的 created_at DESC 进行排序。
提取：只取每组的第一行，丢弃其余行。

为什么它在你的 LEFT JOIN 中很有用？
在你的例子中，由于加了 ORDER BY id, created_at DESC，DISTINCT ON (id) 保证了对于每一个 id，只返回最近创建的那一条记录的 some_col。这样在与 A 表连接时，就不会因为 B 表中有重复的 id 而导致 A 表的数据翻倍。

### 核心区别对比

特性,DISTINCT,DISTINCT ON (col)
去重范围,作用于 SELECT 列表中的所有列。,作用于括号内指定的列。
数据保留,只要有一列不同，就会保留。,只要括号内的列相同，就只留一行。
控制力,无法控制保留哪一行（随机性）。,配合 ORDER BY 可以精准控制保留哪一行（如最新、最贵）。
语法强制,无需配合 ORDER BY。,强制要求 ORDER BY 的最左侧列必须包含在 DISTINCT ON 中。

### 举个例子

假设表 B 数据如下：
id,some_col,created_at
1,"""苹果""",2023-01-01
1,"""香蕉""",2023-05-01

执行 DISTINCT：你会得到 2 行，因为“苹果”和“香蕉”不同。

执行 DISTINCT ON (id) ... ORDER BY id, created_at DESC：你只会得到 1 行：1, "香蕉"。

注意事项 (openGauss 避坑)
排序要求：使用 DISTINCT ON 时，ORDER BY 的第一个表达式必须与 DISTINCT ON 括号里的表达式匹配。例如 DISTINCT ON (id) 必须对应 ORDER BY id, ...。

性能：在数据量巨大且没有合适索引时，DISTINCT ON 会触发物理排序，比较耗时。如果 B.id 和 B.created_at 有联合索引，性能会非常快。

## rank() 和 dense_rank() 是什么？

在 openGauss、PostgreSQL 以及几乎所有的主流关系型数据库中，RANK() 和 DENSE_RANK() 都是窗口函数，专门用于对数据进行排名。

它们最大的区别在于：当出现“并列第一（平分）”的情况时，如何处理后续的排名序号。

### RANK()：跳跃排名

如果两个人并列第一，那么下一个人的排名会跳过第二名，直接变成第三名。

特点：总排名会反映出总人数。如果有两个第 1 名，接下来的就是第 3 名。

### DENSE_RANK()：连续排名

即使有并列第一，排名也是连续的，不会跳号。

特点：排名是“紧凑（Dense）”的。如果有两个第 1 名，接下来的依然是第 2 名。

### 直观对比图

假设有一组考试成绩：
姓名,成绩,RANK(),DENSE_RANK(),ROW_NUMBER() (对比用)
张三,100,1,1,1
李四,100,1,1,2
王五,95,3 (跳过了2),2 (连续),3
赵六,90,4,3,4

### 基本语法

它们的语法结构完全一致：

```sql
SELECT 
    name, 
    score,
    RANK() OVER (ORDER BY score DESC) as rank_val,
    DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank_val
FROM students;
```

OVER: 开启窗口函数。

ORDER BY: 决定按什么标准排名（通常降序 DESC 代表从高分到低分）。

PARTITION BY (可选): 如果你想按班级排名（每个班级内部重新从 1 开始排），可以在 ORDER BY 前加上 PARTITION BY class_id。

### 什么时候用哪个？

- 用 RANK() 的场景： 通常用于竞赛或正式排名。比如奥林匹克比赛，如果有两个并列金牌，接下来的那个人领的就是铜牌（第三名），而不是银牌。
- 用 DENSE_RANK() 的场景： 通常用于等级划分。比如你想知道成绩最好的前三个分数段，而不关心有多少人拿了最高分。
- 用 ROW_NUMBER() 的场景（顺便提一下）： 如果你不需要考虑并列，只是单纯想给每一行打个唯一的序号（比如分页查询），那就用 ROW_NUMBER()。

总结口诀
RANK 是“占位”的：有人并列，位子也占着，后面的人往后挪。

DENSE_RANK 是“排队”的：有人并列，名次照样数，后面的人不吃亏。

你想针对你的 openGauss 数据库写一个具体的“分组排名”查询（比如查询每个部门薪水最高的前三名）吗？我可以帮你写出完整的 SQL。

在 SQL 中，ROW_NUMBER() 的用法与 RANK()、DENSE_RANK() 完全一致。

即使你不需要考虑并列情况，OVER() 子句中的内容通常也是相同的，因为它们都需要基于同样的排序逻辑来计算序号。

1. 完整 SQL 示例
你可以直接运行这段代码，它会将三种排名方式并列显示：

```sql
SELECT 
    name, 
    score,
    -- 无论分数是否相同，序号永远唯一且连续 (1, 2, 3, 4...)
    ROW_NUMBER() OVER (ORDER BY score DESC) as row_num,
    
    -- 分数相同时序号相同，但会跳过后续序号 (1, 1, 3...)
    RANK() OVER (ORDER BY score DESC) as rank_val,
    
    -- 分数相同时序号相同，且序号连续 (1, 1, 2...)
    DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank_val
FROM students;
```

### 为什么 OVER() 里的内容是一样的？

OVER() 子句的作用是定义**“窗口”**，也就是告诉数据库：

怎么切分数据？ (PARTITION BY) —— 比如按班级切分。

按什么顺序排？ (ORDER BY) —— 比如按成绩从高到低。

在这个查询中，三者共用 ORDER BY score DESC，是因为你想在同一个“成绩单”视角下观察它们处理并列分数的不同逻辑。

### 进阶：分组排名（每个部门的前三名）

如果你想查询每个部门（department）中，成绩最高的前 3 名，代码应该这样写：

```sql
SELECT * FROM (
    SELECT 
        name, 
        department,
        score,
        -- 在每个部门内部独立排名
        DENSE_RANK() OVER (PARTITION BY department ORDER BY score DESC) as dr
    FROM students
) t
WHERE t.dr <= 3;
```

PARTITION BY department: 就像是把学生按部门分到了不同的房间里，每个房间的人都从 1 开始重新排名。

外层嵌套: 必须先在子查询里算出排名，外层才能用 WHERE 过滤（因为窗口函数在 SQL 执行顺序中非常靠后）。

### 总结三者关系

函数,结果序列（遇并列）,特点,常用场景
ROW_NUMBER(),"1, 2, 3, 4",绝对唯一,分页、去重、取第一条
RANK(),"1, 1, 3, 4",总数不变,体育比赛、正式名次
DENSE_RANK(),"1, 1, 2, 3",等级连续,绩效评级、分数段统计

## lag,led是什么？

在 openGauss 和 PostgreSQL 的窗口函数世界里，LAG() 和 LEAD() 被称为“偏移函数”。它们的作用非常强大：让你在当前行就能直接读到“上一行”或“下一行”的数据。 这在处理时间序列、计算环比增长或查找状态变更时简直是神器。1. 基本定义LAG(column, n): 获取当前行之前的第 $n$ 行数据（向上看）。LEAD(column, n): 获取当前行之后的第 $n$ 行数据（向下看）。$n$ 默认为 1（即相邻行）。如果找不到对应行（比如第一行的上一行），默认返回 NULL。

### 语法结构

```sql
SELECT 
    dt, 
    sales,
    -- 获取昨天的销售额
    LAG(sales, 1) OVER (ORDER BY dt) as yesterday_sales,
    -- 获取明天的销售额
    LEAD(sales, 1) OVER (ORDER BY dt) as tomorrow_sales
FROM daily_sales;
```

### 实战案例：计算环比增长率

假设你有一张月度营收表，想计算每个月比上个月增长了多少：

```sql
SELECT 
    month,
    revenue,
    LAG(revenue) OVER (ORDER BY month) as last_month_revenue,
    -- 计算增长率：(本月 - 上月) / 上月
    (revenue - LAG(revenue) OVER (ORDER BY month)) / LAG(revenue) OVER (ORDER BY month) * 100 || '%' as growth_rate
FROM monthly_report;
```

### 进阶参数：处理空值和偏移量

LAG 和 LEAD 其实支持三个参数： LAG(column, offset, default_value)

1. column: 你要读取的列。
2. offset: 偏移量（比如填 7 就是看上周同一天）。
3. default_value: 当没有上一行时，用什么代替 NULL（比如填 0）。

```sql
-- 如果没有上一行数据，就显示 0
SELECT LAG(price, 1, 0) OVER (ORDER BY id) FROM products;
```

### 常见应用场景

- 计算差值：如今日股价与昨日股价的差。
- 判断状态变化：对比当前行状态和上一行状态，如果不一致，说明状态发生了切换。
- 计算时间间隔：计算用户本次点击与上次点击之间隔了多少秒。

窗口函数全家桶总结
至此，你已经接触了窗口函数中最核心的三类：

- 排名类：ROW_NUMBER, RANK, DENSE_RANK（解决“谁是第一”）。
- 偏移类：LAG, LEAD（解决“昨天和今天比”）。
- 聚合类：SUM(...) OVER, AVG(...) OVER（解决“个人与平均水平比”）。

你想尝试写一个复杂的查询吗？比如：找出连续 3 天登录的用户。这类问题通常需要将 LAG 或 LEAD 组合使用。

## 连续 3 天登录的用户

这是一个非常经典的 SQL 面试题及实战场景。要找出**“连续 3 天登录的用户”**，我们可以利用 LAG（看前几天）或者 LEAD（看后几天）来跨行对比日期。

假设你的表名为 user_log，字段有 user_id 和 login_date。

方案一：使用 LAG 函数（向前看）
逻辑：如果一个用户“今天的日期”、“昨天的日期”、“前天的日期”是连续的，那么他就是连续 3 天登录。

```sql
SELECT DISTINCT user_id
FROM (
    SELECT 
        user_id,
        login_date,
        -- 获取上一次登录日期
        LAG(login_date, 1) OVER (PARTITION BY user_id ORDER BY login_date) as last_1_day,
        -- 获取上上次登录日期
        LAG(login_date, 2) OVER (PARTITION BY user_id ORDER BY login_date) as last_2_day
    FROM (
        -- 先去重，防止同一天多次登录干扰计算
        SELECT DISTINCT user_id, login_date FROM user_log
    ) as sub_logs
) as t
WHERE login_date = last_1_day + 1  -- 今天 = 昨天 + 1天
  AND last_1_day = last_2_day + 1; -- 昨天 = 前天 + 1天
```

方案二：差值法（高级且通用）
如果要求的是“连续 7 天”甚至更长，写一堆 LAG 会非常痛苦。这时候可以用差值分组法。

核心思想： 如果日期是连续的（如 1号, 2号, 3号），而行号也是连续的（如 1, 2, 3），那么 日期 - 行号 得到的结果必然是同一个常量。

```sql
SELECT user_id
FROM (
    SELECT 
        user_id,
        login_date,
        -- 日期减去行号，得到一个基准日期
        login_date - CAST(ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY login_date) AS INT) as grp
    FROM (SELECT DISTINCT user_id, login_date FROM user_log)
) t
GROUP BY user_id, grp
HAVING COUNT(*) >= 3; -- 只要同一个基准日期的行数 >= 3，就是连续 3 天
```

窗口函数学习小结
恭喜你！到这里你已经掌握了 openGauss/PostgreSQL 中最高级的查询技巧：

DISTINCT ON: 解决“每组只取一个”的去重问题。

RANK/DENSE_RANK/ROW_NUMBER: 解决“名次”和“唯一序号”问题。

LAG/LEAD: 解决“跨行对比”和“趋势分析”问题。

OVER(PARTITION BY ... ORDER BY ...): 窗口函数的核心语法骨架。

## group by 后面的 having 是干什么的？为什么要 having, where 不行嘛？

简单来说：WHERE 作用于“行”（过滤原始数据），而 HAVING 作用于“组”（过滤聚合后的结果）。

### 执行顺序的本质区别

SQL 的执行顺序（逻辑上）是这样的：

1. FROM / JOIN：找到表。
2. WHERE：在分组前，把不符合条件的行扔掉。
3. GROUP BY：把剩下的行分成小组。
4. 聚合函数 (SUM, COUNT, AVG)：计算每个小组的统计值。
5. HAVING：在分组计算完成后，把不符合条件的小组扔掉。

### 为什么 WHERE 不行？

如果你想查“平均分大于 80 的班级”，你会发现：

```sql
-- 报错！因为执行 WHERE 时，数据库还没算出平均分呢
SELECT class_id, AVG(score) 
FROM students 
WHERE AVG(score) > 80 
GROUP BY class_id;
```

报错原因：WHERE 后面严禁使用聚合函数。它只能看单行数据的列。 正确写法：

```sql
SELECT class_id, AVG(score) 
FROM students 
GROUP BY class_id 
HAVING AVG(score) > 80;
```

## openGauss 慢 SQL 监控

在 DataGrip 中，如果你有足够的权限，可以通过 openGauss 内置的性能视图直接定位那些“跑得慢”的语句。

### 查看当前正在运行的慢 SQL

如果你发现数据库卡住了，执行这个：

```sql
SELECT 
    query_id, 
    start_time, 
    now() - start_time AS duration, -- 已运行时间
    query 
FROM pg_stat_activity 
WHERE state != 'idle'               -- 排除空闲连接
ORDER BY duration DESC;
```

### 查看历史累计最耗时的 SQL (WDR 报告基础)

openGauss 提供了一个非常强大的视图 dbe_perf.statement（或者在某些版本中是 pg_stat_statements），它记录了 SQL 的执行次数、总耗时等。

```sql
SELECT 
    user_name,
    query,
    n_calls as 执行次数,
    total_elapse_time / n_calls as 平均耗时_ms,
    n_soft_parse as 软解析,
    n_hard_parse as 硬解析
FROM dbe_perf.statement
ORDER BY 平均耗时_ms DESC
LIMIT 10;
```

## 如何选择过滤工具？

工具,过滤对象,允许聚合函数？,场景示例
WHERE,原始行数据,否,找出所有 2025 年的订单
HAVING,分组后的统计结果,是,找出订单总额超过 100 万的客户
QUALIFY,窗口函数的结果,是,(高级用法) 过滤 ROW_NUMBER() 结果
